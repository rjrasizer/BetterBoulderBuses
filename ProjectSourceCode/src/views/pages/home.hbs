<!-- Full-page Mapbox map for Better Boulder Buses -->
<style>
  /* Hide the global footer on the map page to avoid overlaying the map */
  footer {
    display: none;
  }

  html,
  body {
    height: 100%;
    margin: 0;
  }

  /* Ensure the map fills the visible page area */
  #map {
    position: fixed;
    /* Fully cover the viewport regardless of page flow */
    inset: 0;
    width: 100%;
    height: 100%;
    background: #f5f5f5;
    /* fallback background before tiles load */
  }

  /* Optional: a small overlay to verify the page loaded */
  .overlay {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 1;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 14px;
    color: #333;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);
  }

  .overlay .status-ok {
    color: #198754;
  }

  .overlay .status-warn {
    color: #dc3545;
  }

  .overlay .status-info {
    color: #0d6efd;
  }


  #settings-btn {
 position: fixed;
 top: 16px;
 right: 16px;
 z-index: 10;
}


#settings-btn a {
 display: flex;
 align-items: center;
 justify-content: center;


 width: 42px;
 height: 42px;


 background: rgba(255, 255, 255, 0.9);
 border-radius: 12px;


 box-shadow: 0 2px 8px rgba(0,0,0,0.15);
 backdrop-filter: blur(6px);


 text-decoration: none;
 color: #333;
 transition: background 0.2s ease, transform 0.2s ease;
}


#settings-btn i {
 font-size: 20px;
}


/* Continuous spin animation */
@keyframes spin-gear {
 from {
   transform: rotate(0deg);
 }
 to {
   transform: rotate(360deg);
 }
}


#settings-btn:hover a {
 background: rgba(255, 255, 255, 1);
}


#settings-btn:hover i {
 animation: spin-gear 0.8s linear infinite;
}


</style>

<link rel="stylesheet" href="/css/sidebar.css" />
<!-- Mapbox GL JS CSS is included in main layout head -->

<div class="overlay">
  <strong>Better Boulder Buses</strong>
  <span> — Map status:
    {{#if mapboxToken}}<span id="map-status" class="status-ok">token set</span>{{else}}<span id="map-status"
      class="status-warn">missing token</span>{{/if}}
  </span>
  {{#if title}}<div>{{title}}</div>{{/if}}
  <div style="font-size: 12px; color: #666;">/home</div>
  <div id="diag" style="font-size:12px;color:#666;max-width:320px;word-break:break-all"></div>
  <!-- MVP: Simple routes list -->
  <div id="routesPanel"
    style="margin-top:8px;max-height:220px;overflow:auto;border:1px solid #ddd;border-radius:6px;padding:6px;background:#fff;min-width:260px;">
    <div style="font-weight:600;margin-bottom:6px;display:flex;align-items:center;gap:8px;">
      <span>Routes</span>
      <span id="routesCount" style="font-size:12px;color:#666;"></span>
    </div>
    <ul id="routeList" style="list-style:none;padding:0;margin:0;font-size:13px;line-height:1.4;"></ul>
  </div>
</div>

<div id="map" role="region" aria-label="Interactive transit map"></div>

<a href="/settings" class="position-fixed top-0 end-0 m-3 text-dark">
  <i class="bi bi-gear-fill fs-3"></i>
</a>

<div class="sidebar is-closed">
  <button class="sidebar-toggle is-closed">
    <i class="fa fa-plus icon"></i>
  </button>

  <div class="sidebar-header">
    <h2 class="sidebar-title">Routes</h2>
  </div>
  <div class="sidebar-scroll-container">
    <ul class="sidebar-route-list" id="sidebarRouteList">
      {{!-- will have sidebar data entries here --}}
    </ul>
  </div>
</div>

{{!-- <!-- Sidebar (mobile + desktop) -->
<div class="sidebar is-closed">
  <div class="sidebar-header">
    <h2 class="sidebar-title">Routes</h2>
  </div>
  <ul class="sidebar-route-list" id="sidebarRouteList">
    <!-- sidebar content -->
  </ul>
</div>

<!-- Toggle button (always visible, independent) -->
<button class="sidebar-toggle is-closed">
  <i class="fa fa-plus icon"></i>
</button> --}}

<!-- Mapbox GL JS script -->
<script src="https://api.mapbox.com/mapbox-gl-js/v2.16.1/mapbox-gl.js"></script>

<!-- Sidebar Script -->
<script src="js/script.js"></script>

<script>
  (function () {
    // Token passed from server via template
    var tokenFromServer = '{{mapboxToken}}';

    if (!tokenFromServer || tokenFromServer === '' || tokenFromServer === 'undefined') {
      console.error('Mapbox access token is missing. Set MAPBOX_ACCESS_TOKEN in your .env and restart.');
      return;
    }

    function setStatus(text, cls) {
      var s = document.getElementById('map-status');
      if (s) { s.className = cls || 'status-info'; s.textContent = text; }
      var d = document.getElementById('diag');
      if (d) d.textContent = text;
    }

    function loadScript(src) {
      return new Promise(function (resolve, reject) {
        var s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = resolve;
        s.onerror = function (e) { reject(new Error('Failed to load ' + src)); };
        document.head.appendChild(s);
      });
    }

    function loadCSS(href) {
      return new Promise(function (resolve, reject) {
        var l = document.createElement('link');
        l.rel = 'stylesheet';
        l.href = href;
        l.onload = resolve;
        l.onerror = function () { reject(new Error('Failed to load ' + href)); };
        document.head.appendChild(l);
      });
    }

    function initMapbox() {
      if (typeof mapboxgl === 'undefined') {
        console.warn('mapboxgl undefined before init; attempting alternate CDN...');
        // Try alternate CDN (unpkg) with a known version
        return Promise.all([
          loadCSS('https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css'),
          loadScript('https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js')
        ])
          .then(function () {
            if (typeof mapboxgl === 'undefined') throw new Error('mapboxgl still undefined after alternate CDN');
            return createMapboxMap();
          })
          .catch(function (err) {
            console.error(err);
            setStatus('Mapbox GL JS failed (blockers?). Falling back to MapLibre…', 'status-warn');
            return initMapLibre();
          });
      }
      return createMapboxMap();
    }

    function createMapboxMap() {
      mapboxgl.accessToken = tokenFromServer;
      if (!mapboxgl.supported()) {
        console.error('WebGL not supported in this browser/device.');
        setStatus('WebGL not supported. Enable hardware acceleration or try another browser.', 'status-warn');
        return;
      }
      var map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [-105.2705, 40.0150],
        zoom: 12
      });
      map.addControl(new mapboxgl.NavigationControl(), 'top-right');
      map.on('load', function () {
        setStatus('loaded', 'status-info');

        // Helpers shared by Mapbox GL + MapLibre
        function fetchJSON(url) { return fetch(url).then(function (r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); }); }
        function stopsToFC(stops) { return { type: 'FeatureCollection', features: stops.map(function (s) { return { type: 'Feature', properties: { name: s.stop_name }, geometry: { type: 'Point', coordinates: [+s.lon, +s.lat] } }; }) }; }
        function upsertSource(map, id, data) { if (map.getSource(id)) { map.getSource(id).setData(data); } else { map.addSource(id, { type: 'geojson', data: data }); } }
        function ensureLayers(map) {
          if (!map.getLayer('route-line')) {
            map.addLayer({ id: 'route-line', type: 'line', source: 'route', paint: { 'line-color': '#2563eb', 'line-width': 4 } });
          }
          if (!map.getLayer('stops-circles')) {
            map.addLayer({ id: 'stops-circles', type: 'circle', source: 'stops', paint: { 'circle-radius': 5, 'circle-color': '#ef4444', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 } });
          }
          if (!map.getLayer('stops-labels')) {
            map.addLayer({ id: 'stops-labels', type: 'symbol', source: 'stops', layout: { 'text-field': ['get', 'name'], 'text-size': 12, 'text-offset': [0, 1.2], 'text-anchor': 'top' }, paint: { 'text-color': '#111827' } });
          }
        }
        function fitToShape(map, shapeFC) { try { var Bounds = (window.mapboxgl && mapboxgl.LngLatBounds) || (window.maplibregl && maplibregl.LngLatBounds); var b = new Bounds(); var coords = shapeFC.features[0].geometry.coordinates; coords.forEach(function (c) { b.extend(c); }); map.fitBounds(b, { padding: 50, duration: 0 }); } catch (e) { console.warn('fit bounds failed', e); } }

        function loadRoute(map, routeId, directionId) {
          Promise.all([
            fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/shape?direction_id=' + directionId),
            fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/stops?direction_id=' + directionId)
          ]).then(function (results) {
            var shape = results[0];
            var stops = results[1];
            upsertSource(map, 'route', shape);
            upsertSource(map, 'stops', stopsToFC(stops));
            ensureLayers(map);
            fitToShape(map, shape);
            setStatus('Route ' + routeId + ' dir ' + directionId + ' loaded', 'status-info');

            // Kick off estimate polling for this route/direction
            startEstimatePolling(map, routeId, directionId);
          }).catch(function (err) { console.error('loadRoute error', err); setStatus('loadRoute error: ' + err.message, 'status-warn'); });
        }

        // --- Estimated position polling (every ~25s) ---
        var estimateTimer = null;
        var estimateMarker = null;
        function updateEstimate(map, routeId, directionId) {
          fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/estimate?direction_id=' + directionId)
            .then(function (e) {
              if (!e || !e.position) return;
              var lngLat = [e.position.lng, e.position.lat];
              if (!estimateMarker) {
                var el = document.createElement('div');
                el.style.width = '18px';
                el.style.height = '18px';
                el.style.background = '#10b981';
                el.style.border = '2px solid #fff';
                el.style.borderRadius = '50%';
                el.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
                el.title = 'Estimated Bus';
                estimateMarker = new mapboxgl.Marker({ element: el, rotationAlignment: 'map' })
                  .setLngLat(lngLat)
                  .addTo(map);
              } else {
                estimateMarker.setLngLat(lngLat);
              }
            })
            .catch(function (err) { console.error('estimate fetch error', err); });
        }
        function startEstimatePolling(map, routeId, directionId) {
          if (estimateTimer) { clearInterval(estimateTimer); estimateTimer = null; }
          // reset existing marker between routes
          if (estimateMarker && estimateMarker.remove) { estimateMarker.remove(); estimateMarker = null; }
          // initial fetch immediately
          updateEstimate(map, routeId, directionId);
          // poll roughly every 25 seconds
          estimateTimer = setInterval(function () { updateEstimate(map, routeId, directionId); }, 25000);
        }

        // --- Routes list (MVP) ---
        var state = { currentRouteId: 'FF1', currentDir: 0 };
        function selectRoute(routeId) {
          // Get available directions; pick the first
          fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/directions')
            .then(function (dirs) {
              var dir = Array.isArray(dirs) && dirs.length ? dirs[0] : 0;
              state.currentRouteId = routeId; state.currentDir = dir;
              loadRoute(map, routeId, dir);
            })
            .catch(function (err) { console.error('directions error', err); setStatus('directions error: ' + err.message, 'status-warn'); });
        }
        function loadRoutesList() {
          fetchJSON('/api/routes')
            .then(function (routes) {
              var ul = document.getElementById('routeList');
              var countEl = document.getElementById('routesCount');
              if (countEl) countEl.textContent = '(' + routes.length + ')';
              ul.innerHTML = '';
              routes.slice(0, 40).forEach(function (r) {
                var li = document.createElement('li');
                var btn = document.createElement('button');
                btn.type = 'button';
                btn.textContent = (r.route_short_name || r.route_id) + ' — ' + (r.route_long_name || '');
                btn.style.cssText = 'display:block;width:100%;text-align:left;padding:4px 6px;margin:2px 0;border:1px solid #ddd;border-radius:4px;background:#f8f9fa;cursor:pointer;';
                btn.addEventListener('click', function () { selectRoute(r.route_id); });
                li.appendChild(btn);
                ul.appendChild(li);
              });
            })
            .catch(function (err) { console.error('loadRoutesList error', err); });
        }

        // Draw a real GTFS route without adding any extra HTML
        loadRoute(map, state.currentRouteId, state.currentDir);
        loadRoutesList();
      });
      map.on('error', function (e) {
        console.error('Mapbox GL error:', e && e.error ? e.error : e);
        setStatus('Map error: ' + (e && e.error && e.error.message ? e.error.message : 'see console'), 'status-warn');
      });
    }

    function initMapLibre() {
      // Load MapLibre JS and CSS and render a demo style as a fallback
      return loadCSS('https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css')
        .then(function () { return loadScript('https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js'); })
        .then(function () {
          if (typeof maplibregl === 'undefined') throw new Error('maplibregl undefined');
          var map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json',
            center: [-105.2705, 40.0150],
            zoom: 12
          });
          map.addControl(new maplibregl.NavigationControl(), 'top-right');
          map.on('load', function () {
            setStatus('fallback loaded (MapLibre)', 'status-info');

            // Use same API-driven flow as Mapbox path
            function fetchJSON(url) { return fetch(url).then(function (r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); }); }
            function stopsToFC(stops) { return { type: 'FeatureCollection', features: stops.map(function (s) { return { type: 'Feature', properties: { name: s.stop_name }, geometry: { type: 'Point', coordinates: [+s.lon, +s.lat] } }; }) }; }
            function upsertSource(map, id, data) { if (map.getSource(id)) { map.getSource(id).setData(data); } else { map.addSource(id, { type: 'geojson', data: data }); } }
            function ensureLayers(map) {
              if (!map.getLayer('route-line')) {
                map.addLayer({ id: 'route-line', type: 'line', source: 'route', paint: { 'line-color': '#2563eb', 'line-width': 4 } });
              }
              if (!map.getLayer('stops-circles')) {
                map.addLayer({ id: 'stops-circles', type: 'circle', source: 'stops', paint: { 'circle-radius': 5, 'circle-color': '#ef4444', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 } });
              }
              if (!map.getLayer('stops-labels')) {
                map.addLayer({ id: 'stops-labels', type: 'symbol', source: 'stops', layout: { 'text-field': ['get', 'name'], 'text-size': 12, 'text-offset': [0, 1.2], 'text-anchor': 'top' }, paint: { 'text-color': '#111827' } });
              }
            }
            function fitToShape(map, shapeFC) { try { var Bounds = (window.mapboxgl && mapboxgl.LngLatBounds) || (window.maplibregl && maplibregl.LngLatBounds); var b = new Bounds(); var coords = shapeFC.features[0].geometry.coordinates; coords.forEach(function (c) { b.extend(c); }); map.fitBounds(b, { padding: 50, duration: 0 }); } catch (e) { console.warn('fit bounds failed', e); } }

            function loadRoute(map, routeId, directionId) {
              Promise.all([
                fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/shape?direction_id=' + directionId),
                fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/stops?direction_id=' + directionId)
              ]).then(function (results) {
                var shape = results[0];
                var stops = results[1];
                upsertSource(map, 'route', shape);
                upsertSource(map, 'stops', stopsToFC(stops));
                ensureLayers(map);
                fitToShape(map, shape);
                setStatus('Route ' + routeId + ' dir ' + directionId + ' loaded', 'status-info');
                startEstimatePolling(map, routeId, directionId);
              }).catch(function (err) { console.error('loadRoute error', err); setStatus('loadRoute error: ' + err.message, 'status-warn'); });
            }

            var estimateTimer = null;
            var estimateMarker = null;
            function updateEstimate(map, routeId, directionId) {
              fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/estimate?direction_id=' + directionId)
                .then(function (e) {
                  if (!e || !e.position) return;
                  var lngLat = [e.position.lng, e.position.lat];
                  if (!estimateMarker) {
                    var el = document.createElement('div');
                    el.style.width = '18px'; el.style.height = '18px';
                    el.style.background = '#10b981'; el.style.border = '2px solid #fff';
                    el.style.borderRadius = '50%'; el.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
                    el.title = 'Estimated Bus';
                    estimateMarker = new maplibregl.Marker({ element: el })
                      .setLngLat(lngLat)
                      .addTo(map);
                  } else {
                    estimateMarker.setLngLat(lngLat);
                  }
                })
                .catch(function (err) { console.error('estimate fetch error', err); });
            }
            function startEstimatePolling(map, routeId, directionId) {
              if (estimateTimer) { clearInterval(estimateTimer); estimateTimer = null; }
              if (estimateMarker && estimateMarker.remove) { estimateMarker.remove(); estimateMarker = null; }
              updateEstimate(map, routeId, directionId);
              estimateTimer = setInterval(function () { updateEstimate(map, routeId, directionId); }, 25000);
            }

            var state = { currentRouteId: 'FF1', currentDir: 0 };
            function selectRoute(routeId) {
              fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/directions')
                .then(function (dirs) {
                  var dir = Array.isArray(dirs) && dirs.length ? dirs[0] : 0;
                  state.currentRouteId = routeId; state.currentDir = dir;
                  loadRoute(map, routeId, dir);
                })
                .catch(function (err) { console.error('directions error', err); setStatus('directions error: ' + err.message, 'status-warn'); });
            }
            function loadRoutesList() {
              fetchJSON('/api/routes')
                .then(function (routes) {
                  var ul = document.getElementById('routeList');
                  var countEl = document.getElementById('routesCount');
                  if (countEl) countEl.textContent = '(' + routes.length + ')';
                  ul.innerHTML = '';
                  routes.slice(0, 40).forEach(function (r) {
                    var li = document.createElement('li');
                    var btn = document.createElement('button');
                    btn.type = 'button';
                    btn.textContent = (r.route_short_name || r.route_id) + ' — ' + (r.route_long_name || '');
                    btn.style.cssText = 'display:block;width:100%;text-align:left;padding:4px 6px;margin:2px 0;border:1px solid #ddd;border-radius:4px;background:#f8f9fa;cursor:pointer;';
                    btn.addEventListener('click', function () { selectRoute(r.route_id); });
                    li.appendChild(btn);
                    ul.appendChild(li);
                  });
                })
                .catch(function (err) { console.error('loadRoutesList error', err); });
            }

            // Start with default and load list
            loadRoute(map, state.currentRouteId, state.currentDir);
            loadRoutesList();
          });
          map.on('error', function (e) { console.error('MapLibre error:', e); setStatus('MapLibre error: see console', 'status-warn'); });
        })
        .catch(function (e) { console.error(e); setStatus('Fallback failed to load. See console.', 'status-warn'); });
    }

    function start() {
      if (!tokenFromServer || tokenFromServer === '' || tokenFromServer === 'undefined') {
        console.error('Mapbox access token is missing. Set MAPBOX_ACCESS_TOKEN in your .env and restart.');
        return;
      }
      initMapbox();
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      start();
    } else {
      window.addEventListener('DOMContentLoaded', start);
    }
  })();
</script>