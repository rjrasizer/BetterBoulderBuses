<!-- Full-page Mapbox map for Better Boulder Buses -->
<style>
  /* Hide the global footer on the map page to avoid overlaying the map */
  footer {
    display: none;
  }

  html,
  body {
    height: 100%;
    margin: 0;
  }

  /* Ensure the map fills the visible page area */
  #map {
    position: fixed;
    /* Fully cover the viewport regardless of page flow */
    inset: 0;
    width: 100%;
    height: 100%;
    background: #f5f5f5;
    /* fallback background before tiles load */
  }

  /* Optional: a small overlay to verify the page loaded */
  .overlay {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 1;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 14px;
    color: #333;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);
  }

  .overlay .status-ok {
    color: #198754;
  }

  .overlay .status-warn {
    color: #dc3545;
  }

  .overlay .status-info {
    color: #0d6efd;
  }


  #settings-btn {
    position: fixed;
    top: 16px;
    right: 16px;
    z-index: 10;
  }


  #settings-btn a {
    display: flex;
    align-items: center;
    justify-content: center;


    width: 42px;
    height: 42px;


    background: rgba(255, 255, 255, 0.9);
    border-radius: 12px;


    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(6px);


    text-decoration: none;
    color: #333;
    transition: background 0.2s ease, transform 0.2s ease;
  }


  #settings-btn i {
    font-size: 20px;
  }


  /* Continuous spin animation */
  @keyframes spin-gear {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }


  #settings-btn:hover a {
    background: rgba(255, 255, 255, 1);
  }


  #settings-btn:hover i {
    animation: spin-gear 0.8s linear infinite;
  }

  #recenter-btn i {
    font-size: 1.2rem;
    font-weight: bold;
  }

  #recenter-btn {
    position: fixed;
    top: 68px;
    right: 16px;
    z-index: 10;
    padding: 8px 12px;
    border-radius: 999px;
    border: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    font-size: 14px;
  }

  #recenter-btn:hover {
    background: #ffffff;
  }

  #nearest-btn {
    position: fixed;
    top: 112px;
    right: 16px;
    z-index: 10;
    padding: 8px 12px;
    border-radius: 999px;
    border: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    font-size: 14px;
  }

  #nearest-btn:hover {
    background: #ffffff;
  }

  #walk-btn {
    position: fixed;
    top: 150px;
    right: 16px;
    z-index: 10;
    padding: 8px 12px;
    border-radius: 999px;
    border: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
  }

  #walk-btn:hover {
    background: #ffffff;
  }

  #walk-btn i {
    font-size: 1.2rem;
    font-weight: bold;
  }

  .action-btn {
  width: 50px;
  height: 50px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.9);
  border: none;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  margin: 4px; /* optional spacing between buttons */
}

.action-btn i {
  font-size: 24px;
  font-weight: bold;
  color: #333;
}
  .route-details {
    margin-top: 6px;
    padding: 8px;
    border-radius: 8px;
    background: #222;
    color: #fff;
  }

  .closest-stop-box {
    padding: 8px;
    border-radius: 8px;
    background: #333;
    margin-bottom: 8px;
  }

  .closest-stop-name {
    font-size: 14px;
    color: #cfb87c;
    margin-bottom: 4px;
  }

  .closest-stop-eta {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 2px;
  }

  .closest-stop-meta {
    font-size: 12px;
    color: #aaa;
  }

  .stops-scroll-container {
    display: flex;
    flex-direction: row;
    overflow-x: auto;
    gap: 8px;
    padding: 4px 0;
    margin-bottom: 8px;
  }

  .stop-card {
    min-width: 140px;
    padding: 8px;
    border-radius: 8px;
    background: #333;
    color: #fff;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }

  .stop-card-name {
    font-size: 12px;
    margin-bottom: 4px;
  }

  .stop-card-eta {
    font-size: 16px;
    font-weight: 600;
  }

  .stop-card-past {
    opacity: 0.6;
  }

  .stop-card-nearest {
    border: 1px solid #cfb87c;
  }

  .closest-stop-menu-button {
    margin-top: 4px;
    width: 100%;
    padding: 6px 8px;
    border-radius: 999px;
    border: 1px solid #cfb87c;
    background: #222;
    color: #cfb87c;
    cursor: pointer;
    font-size: 14px;
  }


</style>

<link rel="stylesheet" href="/css/sidebar.css" />
<!-- Mapbox GL JS CSS is included in main layout head -->

<div class="overlay">
  <strong>Better Boulder Buses</strong>
  <span> — Map status:
    {{#if mapboxToken}}<span id="map-status" class="status-ok">token set</span>{{else}}<span id="map-status"
      class="status-warn">missing token</span>{{/if}}
  </span>
  {{#if title}}<div>{{title}}</div>{{/if}}
  <div style="font-size: 12px; color: #666;">/home</div>
  <div id="diag" style="font-size:12px;color:#666;max-width:320px;word-break:break-all"></div>
</div>

<div id="settings-btn">
  <a href="/settings" aria-label="Open settings">
    <i class="bi bi-gear-fill"></i>
  </a>
</div>

<button
  id="recenter-btn"
  type="button"
  aria-label="Center on my location"
>
  <i class="bi bi-geo-alt"></i>
</button>

<button
  id="nearest-btn"
  type="button"
  aria-label="Find nearest route and stop"
>
  Nearest stop
</button>

<button
  id="walk-btn"
  type="button"
  aria-label="Show walking route to nearest stop"
>
  <i class="bi bi-person"></i>
</button>

<div id="map" role="region" aria-label="Interactive transit map"></div>
{{> sidebar}}
<script src="https://api.mapbox.com/mapbox-gl-js/v2.16.1/mapbox-gl.js"></script>



{{!-- <!-- Sidebar (mobile + desktop) -->
<div class="sidebar is-closed">
  <div class="sidebar-header">
    <h2 class="sidebar-title">Routes</h2>
  </div>
  <ul class="sidebar-route-list" id="sidebarRouteList">
    <!-- sidebar content -->
  </ul>
</div>

<!-- Toggle button (always visible, independent) -->
<button class="sidebar-toggle is-closed">
  <i class="fa fa-plus icon"></i>
</button> --}}



<!-- Sidebar Script -->
<script src="js/script.js"></script>

<script>
  (function () {
    // Token passed from server via template
    var tokenFromServer = '{{mapboxToken}}';

    if (!tokenFromServer || tokenFromServer === '' || tokenFromServer === 'undefined') {
      console.error('Mapbox access token is missing. Set MAPBOX_ACCESS_TOKEN in your .env and restart.');
      return;
    }

    function setStatus(text, cls) {
      var s = document.getElementById('map-status');
      if (s) { s.className = cls || 'status-info'; s.textContent = text; }
      var d = document.getElementById('diag');
      if (d) d.textContent = text;
    }

    function loadScript(src) {
      return new Promise(function (resolve, reject) {
        var s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = resolve;
        s.onerror = function (e) { reject(new Error('Failed to load ' + src)); };
        document.head.appendChild(s);
      });
    }

    function loadCSS(href) {
      return new Promise(function (resolve, reject) {
        var l = document.createElement('link');
        l.rel = 'stylesheet';
        l.href = href;
        l.onload = resolve;
        l.onerror = function () { reject(new Error('Failed to load ' + href)); };
        document.head.appendChild(l);
      });
    }

    function initMapbox() {
      if (typeof mapboxgl === 'undefined') {
        console.warn('mapboxgl undefined before init; attempting alternate CDN...');
        // Try alternate CDN (unpkg) with a known version
        return Promise.all([
          loadCSS('https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css'),
          loadScript('https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js')
        ])
          .then(function () {
            if (typeof mapboxgl === 'undefined') throw new Error('mapboxgl still undefined after alternate CDN');
            return createMapboxMap();
          })
          .catch(function (err) {
            console.error(err);
            setStatus('Mapbox GL JS failed (blockers?). Falling back to MapLibre…', 'status-warn');
            return initMapLibre();
          });
      }
      return createMapboxMap();
    }

    function createMapboxMap() {
      mapboxgl.accessToken = tokenFromServer;
      if (!mapboxgl.supported()) {
        console.error('WebGL not supported in this browser/device.');
        setStatus('WebGL not supported. Enable hardware acceleration or try another browser.', 'status-warn');
        return;
      }
      var map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [-105.2705, 40.0150],
        zoom: 12
      });

      // -----------------------------
      // USER LOCATION
      // -----------------------------

      // Make sure browser supports location
      if ("geolocation" in navigator) {
        navigator.geolocation.watchPosition(
          (position) => {
            const userLng = position.coords.longitude;
            const userLat = position.coords.latitude;

            // Track latest user location for nearest-stop logic
            window.userLocation = {
              lat: userLat,
              lng: userLng,
              hasFix: true
            };

            // If marker doesn't exist yet, create it
            if (!window.userMarker) {
              window.userMarker = new mapboxgl.Marker({
                color: "rgb(207, 184, 124)"  // optional: your chosen color
              })
                .setLngLat([userLng, userLat])
                .addTo(map);

              // Optionally center map on the user the first time
              map.flyTo({ center: [userLng, userLat], zoom: 14 });
            } else {
              // Update existing marker
              window.userMarker.setLngLat([userLng, userLat]);
            }
          },

          (error) => {
            console.error("Geolocation error:", error.message);
            window.userLocation = { hasFix: false };
          },

          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 10000
          }
        );
      } else {
        console.error("Geolocation not supported by this browser.");
      }

      // Recenter-on-user button
      var recenterBtn = document.getElementById('recenter-btn');
      if (recenterBtn) {
        recenterBtn.addEventListener('click', function () {
          // If we already have a user marker, use its position
          if (window.userMarker && typeof window.userMarker.getLngLat === 'function') {
            var lngLat = window.userMarker.getLngLat();
            map.flyTo({ center: [lngLat.lng, lngLat.lat], zoom: 14 });
            return;
          }

          // Fallback: ask for current position once
          if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition(
              function (position) {
                var userLng = position.coords.longitude;
                var userLat = position.coords.latitude;

                // Update cached user location
                window.userLocation = {
                  lat: userLat,
                  lng: userLng,
                  hasFix: true
                };

                if (!window.userMarker) {
                  window.userMarker = new mapboxgl.Marker({
                    color: "rgb(207, 184, 124)"
                  })
                    .setLngLat([userLng, userLat])
                    .addTo(map);
                } else {
                  window.userMarker.setLngLat([userLng, userLat]);
                }

                map.flyTo({ center: [userLng, userLat], zoom: 14 });
              },
              function (error) {
                console.error("Geolocation error (recenter):", error.message);
              },
              {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000
              }
            );
          }
        });
      }

      map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
      map.on('load', function () {
        setStatus('loaded', 'status-info');
              // --- Route cards: data + helpers for 4-card pages ---
      var ALL_ROUTES = [];
      var NEAREST_ROUTES = [];

      function chunkIntoPages(arr, size) {
        var pages = [];
        for (var i = 0; i < arr.length; i += size) {
          pages.push(arr.slice(i, i + size));
        }
        return pages;
      }

        function renderRoutePages(routes) {
          var listEl = document.getElementById('routeList');
          var countEl = document.getElementById('routesCount');
          if (!listEl) return;

          listEl.innerHTML = '';

          if (countEl) {
            countEl.textContent = routes.length ? '(' + routes.length + ')' : '';
          }

          var pages = chunkIntoPages(routes, 4);

          pages.forEach(function (pageRoutes) {
            var pageLi = document.createElement('li');
            pageLi.className = 'route-page';

            pageRoutes.forEach(function (r) {
              var routeId = r.route_id;
              var directionId =
                typeof r.direction_id === 'number' ? r.direction_id : 0;
              var nearestStop = r.nearest_stop || null;

              var card = document.createElement('article');
              card.className = 'route-card';

              // ----------------------
              // Header (name + pill)
              // ----------------------
              var header = document.createElement('div');
              header.className = 'route-card-header';

              var titleWrap = document.createElement('div');

              var title = document.createElement('div');
              title.className = 'route-name';
              title.textContent =
                (r.route_short_name || routeId) + ' — ' + (r.route_long_name || '');

              var subtitle = document.createElement('div');
              subtitle.className = 'route-subtitle';
              subtitle.textContent = 'Tap for live timing & stops';

              titleWrap.appendChild(title);
              titleWrap.appendChild(subtitle);

              var pillBtn = document.createElement('button');
              pillBtn.type = 'button';
              pillBtn.className = 'route-pill-btn';
              pillBtn.textContent = 'Closest stop';

              header.appendChild(titleWrap);
              header.appendChild(pillBtn);
              card.appendChild(header);

              // ----------------------
              // Meta line
              // ----------------------
              var meta = document.createElement('div');
              meta.className = 'route-meta';
              if (nearestStop) {
                var dist =
                  typeof nearestStop.distance_meters === 'number'
                    ? Math.round(nearestStop.distance_meters)
                    : null;
                var text =
                  'Nearest: ' +
                  (nearestStop.stop_name || nearestStop.stop_id || '');
                if (dist !== null) text += ' (~' + dist + ' m)';
                meta.textContent = text;
              } else {
                meta.textContent = 'Nearest stop: unknown';
              }
              card.appendChild(meta);

              // ----------------------
              // Details panel (LIVE INFO)
              // ----------------------
              var details = document.createElement('div');
              details.className = 'route-details';
              details.style.display = 'none';

              var routeKey = routeId + ':' + directionId;
              routeDetailsMap[routeKey] = details;

              card.appendChild(details);

              // ----------------------
              // Interactions
              // ----------------------

              // Header click → load route + open timing panel
              header.addEventListener('click', function (ev) {
                ev.stopPropagation(); // don’t double-trigger card click
                state.currentRouteId = routeId;
                state.currentDir = directionId;
                loadRoute(map, routeId, directionId);
                openRouteDetails(routeId, directionId, details, map);
              });

              // Card background click → just load route (no panel toggle)
              card.addEventListener('click', function () {
                state.currentRouteId = routeId;
                state.currentDir = directionId;
                loadRoute(map, routeId, directionId);
              });

              // Pill click → walking route to nearest stop on that route
              pillBtn.addEventListener('click', function (ev) {
                ev.stopPropagation();
                if (!window.userLocation || !window.userLocation.hasFix) {
                  setStatus('Need your location for walking directions.', 'status-warn');
                  return;
                }
                if (!nearestStop) {
                  setStatus('No nearest stop data for this route.', 'status-warn');
                  return;
                }

                window.nearestStop = {
                  stop_id: nearestStop.stop_id,
                  stop_name: nearestStop.stop_name,
                  lat: nearestStop.lat,
                  lon: nearestStop.lon
                };
                window.nearestRoute = {
                  routeId: routeId,
                  directionId: directionId
                };

                state.currentRouteId = routeId;
                state.currentDir = directionId;
                loadRoute(map, routeId, directionId);
                highlightNearestStopOnMap(map, window.nearestStop);
                showWalkingRoute(map);
              });

              pageLi.appendChild(card);
            });

            listEl.appendChild(pageLi);
          });
        }


        // Helpers shared by Mapbox GL + MapLibre
        function fetchJSON(url) { return fetch(url).then(function (r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); }); }
        function stopsToFC(stops) { return { type: 'FeatureCollection', features: stops.map(function (s) { return { type: 'Feature', properties: { name: s.stop_name }, geometry: { type: 'Point', coordinates: [+s.lon, +s.lat] } }; }) }; }
        function upsertSource(map, id, data) { if (map.getSource(id)) { map.getSource(id).setData(data); } else { map.addSource(id, { type: 'geojson', data: data }); } }
        function ensureLayers(map) {
          if (!map.getLayer('route-line')) {
            map.addLayer({ id: 'route-line', type: 'line', source: 'route', paint: { 'line-color': '#2563eb', 'line-width': 4 } });
          }
          if (!map.getLayer('stops-circles')) {
            map.addLayer({ id: 'stops-circles', type: 'circle', source: 'stops', paint: { 'circle-radius': 5, 'circle-color': '#ef4444', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 } });
          }
          if (!map.getLayer('stops-labels')) {
            map.addLayer({ id: 'stops-labels', type: 'symbol', source: 'stops', layout: { 'text-field': ['get', 'name'], 'text-size': 12, 'text-offset': [0, 1.2], 'text-anchor': 'top' }, paint: { 'text-color': '#111827' } });
          }
        }
        function fitToShape(map, shapeFC) { try { var Bounds = (window.mapboxgl && mapboxgl.LngLatBounds) || (window.maplibregl && maplibregl.LngLatBounds); var b = new Bounds(); var coords = shapeFC.features[0].geometry.coordinates; coords.forEach(function (c) { b.extend(c); }); map.fitBounds(b, { padding: 50, duration: 0 }); } catch (e) { console.warn('fit bounds failed', e); } }

        function loadRoute(map, routeId, directionId) {
          Promise.all([
            fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/shape?direction_id=' + directionId),
            fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/stops?direction_id=' + directionId)
          ]).then(function (results) {
            var shape = results[0];
            var stops = results[1];
            upsertSource(map, 'route', shape);
            upsertSource(map, 'stops', stopsToFC(stops));
            ensureLayers(map);
            fitToShape(map, shape);
            setStatus('Route ' + routeId + ' dir ' + directionId + ' loaded', 'status-info');

            // Kick off estimate polling for this route/direction
            startEstimatePolling(map, routeId, directionId);
          }).catch(function (err) { console.error('loadRoute error', err); setStatus('loadRoute error: ' + err.message, 'status-warn'); });
        }

        // --- Estimated position polling (every ~25s) ---
        var estimateTimer = null;
        var estimateMarker = null;
        function updateEstimate(map, routeId, directionId) {
          fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/estimate?direction_id=' + directionId)
            .then(function (e) {
              if (!e || !e.position) return;
              var lngLat = [e.position.lng, e.position.lat];
              if (!estimateMarker) {
                var el = document.createElement('div');
                el.style.width = '18px';
                el.style.height = '18px';
                el.style.background = '#10b981';
                el.style.border = '2px solid #fff';
                el.style.borderRadius = '50%';
                el.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
                el.title = 'Estimated Bus';
                estimateMarker = new mapboxgl.Marker({ element: el, rotationAlignment: 'map' })
                  .setLngLat(lngLat)
                  .addTo(map);
              } else {
                estimateMarker.setLngLat(lngLat);
              }
            })
            .catch(function (err) { console.error('estimate fetch error', err); });
        }
        function startEstimatePolling(map, routeId, directionId) {
          if (estimateTimer) { clearInterval(estimateTimer); estimateTimer = null; }
          // reset existing marker between routes
          if (estimateMarker && estimateMarker.remove) { estimateMarker.remove(); estimateMarker = null; }
          // initial fetch immediately
          updateEstimate(map, routeId, directionId);
          // poll roughly every 25 seconds
          estimateTimer = setInterval(function () { updateEstimate(map, routeId, directionId); }, 25000);
        }

        // --- Route details panel state ---
        var openRouteKey = null;                // e.g., "FF1:0"
        var routeDetailsMap = Object.create(null); // key -> details element

        function renderRouteDetails(detailsEl, data, routeId, directionId, map) {
          detailsEl.innerHTML = '';

          var closest = data.nearest_stop || null;
          var trip = data.trip || null;

          // Closest stop summary box
          var closestBox = document.createElement('div');
          closestBox.className = 'closest-stop-box';

          var closestName = document.createElement('div');
          closestName.className = 'closest-stop-name';
          closestName.textContent = closest && closest.stop_name ? closest.stop_name : 'Closest stop';

          var closestEta = document.createElement('div');
          closestEta.className = 'closest-stop-eta';
          closestEta.textContent = closest && closest.eta_label ? closest.eta_label : 'ETA unknown';

          var closestMeta = document.createElement('div');
          closestMeta.className = 'closest-stop-meta';
          if (trip && trip.now_local) {
            closestMeta.textContent = 'Based on active service at ' + trip.now_local;
          } else {
            closestMeta.textContent = 'No active trip; schedule only';
          }

          closestBox.appendChild(closestName);
          closestBox.appendChild(closestEta);
          closestBox.appendChild(closestMeta);
          detailsEl.appendChild(closestBox);

          // Horizontal scroll of stops with ETAs
          var stops = Array.isArray(data.stops) ? data.stops : [];
          var scroll = document.createElement('div');
          scroll.className = 'stops-scroll-container';

          stops.forEach(function (stop) {
            var card = document.createElement('div');
            card.className = 'stop-card';
            if (stop.is_passed) card.classList.add('stop-card-past');
            if (stop.is_nearest) card.classList.add('stop-card-nearest');

            var nameEl = document.createElement('div');
            nameEl.className = 'stop-card-name';
            nameEl.textContent = stop.stop_name || stop.stop_id || 'Stop';

            var etaEl = document.createElement('div');
            etaEl.className = 'stop-card-eta';
            etaEl.textContent = stop.eta_label || 'ETA ?';

            card.appendChild(nameEl);
            card.appendChild(etaEl);

            card.addEventListener('click', function () {
              if (!window.userLocation || !window.userLocation.hasFix) {
                setStatus('Need your location for walking directions.', 'status-warn');
                return;
              }

              window.nearestStop = {
                stop_id: stop.stop_id,
                stop_name: stop.stop_name,
                lat: stop.lat,
                lon: stop.lon
              };
              window.nearestRoute = {
                routeId: routeId,
                directionId: directionId
              };

              state.currentRouteId = routeId;
              state.currentDir = directionId;
              loadRoute(map, routeId, directionId);
              highlightNearestStopOnMap(map, window.nearestStop);
              showWalkingRoute(map);
            });

            scroll.appendChild(card);
          });

          detailsEl.appendChild(scroll);

          // Walk to closest stop button
          var closestBtn = document.createElement('button');
          closestBtn.type = 'button';
          closestBtn.className = 'closest-stop-menu-button';
          closestBtn.textContent = 'Walk to closest stop';

          closestBtn.addEventListener('click', function () {
            if (!window.userLocation || !window.userLocation.hasFix) {
              setStatus('Need your location for walking directions.', 'status-warn');
              return;
            }
            if (!closest) {
              setStatus('No closest stop data.', 'status-warn');
              return;
            }

            window.nearestStop = {
              stop_id: closest.stop_id,
              stop_name: closest.stop_name,
              lat: closest.lat,
              lon: closest.lon
            };
            window.nearestRoute = {
              routeId: routeId,
              directionId: directionId
            };

            state.currentRouteId = routeId;
            state.currentDir = directionId;
            loadRoute(map, routeId, directionId);
            highlightNearestStopOnMap(map, window.nearestStop);
            showWalkingRoute(map);
          });

          detailsEl.appendChild(closestBtn);
        }

        function openRouteDetails(routeId, directionId, detailsEl, map) {
          var key = routeId + ':' + directionId;

          // Collapse if already open
          if (openRouteKey === key) {
            var isHidden = detailsEl.style.display === 'none';
            detailsEl.style.display = isHidden ? 'block' : 'none';
            if (!isHidden) openRouteKey = null;
            return;
          }

          // Close previously open panel
          if (openRouteKey && routeDetailsMap[openRouteKey]) {
            routeDetailsMap[openRouteKey].style.display = 'none';
          }

          openRouteKey = key;

          if (detailsEl.dataset.loaded === 'true') {
            detailsEl.style.display = 'block';
            return;
          }

          var lat = null, lng = null;
          if (window.userLocation && window.userLocation.hasFix) {
            lat = window.userLocation.lat;
            lng = window.userLocation.lng;
          }

          var url = '/api/routes/' + encodeURIComponent(routeId) +
                    '/timing?direction_id=' + encodeURIComponent(directionId);
          if (lat != null && lng != null) {
            url += '&lat=' + encodeURIComponent(lat) + '&lng=' + encodeURIComponent(lng);
          }

          fetchJSON(url)
            .then(function (data) {
              renderRouteDetails(detailsEl, data, routeId, directionId, map);
              detailsEl.dataset.loaded = 'true';
              detailsEl.style.display = 'block';
            })
            .catch(function (err) {
              console.error('timing error', err);
              setStatus('Failed to load route timing', 'status-warn');
            });
        }

        // --- Nearest route + stop to user ---
        function highlightNearestStopOnMap(map, stop) {
          var sourceId = 'nearest-stop';
          var layerId = 'nearest-stop-circle';
          var fc = {
            type: 'FeatureCollection',
            features: [{
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Point',
                coordinates: [stop.lon, stop.lat]
              }
            }]
          };

          if (map.getSource(sourceId)) {
            map.getSource(sourceId).setData(fc);
          } else {
            map.addSource(sourceId, {
              type: 'geojson',
              data: fc
            });
          }

          if (!map.getLayer(layerId)) {
            map.addLayer({
              id: layerId,
              type: 'circle',
              source: sourceId,
              paint: {
                'circle-radius': 8,
                'circle-color': '#22c55e',
                'circle-stroke-color': '#ffffff',
                'circle-stroke-width': 2
              }
            });
          }
        }

        function findNearestRouteStop(map) {
          if (!window.userLocation || !window.userLocation.hasFix) {
            setStatus('Waiting for your location…', 'status-warn');
            return;
          }

          var lat = window.userLocation.lat;
          var lng = window.userLocation.lng;

          fetchJSON('/api/nearest?lat=' + encodeURIComponent(lat) + '&lng=' + encodeURIComponent(lng))
            .then(function (data) {
              window.nearestStop = data.stop;
              window.nearestRoute = {
                routeId: data.route_id,
                directionId: data.direction_id
              };

              var label = (data.route_short_name || data.route_id) + ' — ' + (data.stop.stop_name || '');
              var dist = typeof data.distance_meters === 'number'
                ? Math.round(data.distance_meters)
                : null;
              var statusText = 'Nearest: ' + label;
              if (dist !== null) statusText += ' (~' + dist + ' m)';
              setStatus(statusText, 'status-info');

              loadRoute(map, data.route_id, data.direction_id);
              highlightNearestStopOnMap(map, data.stop);
            })
            .catch(function (err) {
              console.error('nearest error', err);
              setStatus('Failed to find nearest stop', 'status-warn');
            });
        }

        function buildDirectionsUrl(fromLng, fromLat, toLng, toLat) {
          var token = tokenFromServer;
          var coords = fromLng + ',' + fromLat + ';' + toLng + ',' + toLat;
          return 'https://api.mapbox.com/directions/v5/mapbox/walking/'
            + coords
            + '?geometries=geojson&overview=full&access_token=' + encodeURIComponent(token);
        }
/*
        function showWalkingRoute(map) {
          if (!window.userLocation || !window.userLocation.hasFix || !window.nearestStop) {
            setStatus('Need your location and nearest stop first.', 'status-warn');
            return;
          }

          var fromLat = window.userLocation.lat;
          var fromLng = window.userLocation.lng;
          var toLat = window.nearestStop.lat;
          var toLng = window.nearestStop.lon;

          var url = buildDirectionsUrl(fromLng, fromLat, toLng, toLat);

          fetch(url)
            .then(function (r) {
              if (!r.ok) throw new Error('HTTP ' + r.status);
              return r.json();
            })
            .then(function (json) {
              if (!json.routes || !json.routes.length || !json.routes[0].geometry) {
                setStatus('No walking route found.', 'status-warn');
                return;
              }

              var route = json.routes[0];
              var geometry = route.geometry;
              var sourceId = 'walking-route';
              var layerId = 'walking-route-line';
              var feature = {
                type: 'Feature',
                properties: {},
                geometry: geometry
              };

              if (map.getSource(sourceId)) {
                map.getSource(sourceId).setData(feature);
              } else {
                map.addSource(sourceId, {
                  type: 'geojson',
                  data: feature
                });
              }

              if (!map.getLayer(layerId)) {
                map.addLayer({
                  id: layerId,
                  type: 'line',
                  source: sourceId,
                  paint: {
                    'line-color': '#22c55e',
                    'line-width': 4,
                    'line-dasharray': [1.5, 1.5]
                  }
                });
              }

              try {
                var bounds = new mapboxgl.LngLatBounds();
                geometry.coordinates.forEach(function (c) { bounds.extend(c); });
                map.fitBounds(bounds, { padding: 60 });
              } catch (e) {
                console.warn('walk fit failed', e);
              }

              var dist = typeof route.distance === 'number' ? Math.round(route.distance) : null;
              var statusText = 'Walking route ready';
              if (dist !== null) statusText += ' (~' + dist + ' m)';
              setStatus(statusText, 'status-info');
            })
            .catch(function (err) {
              console.error('directions error', err);
              setStatus('Failed to load walking route', 'status-warn');
            });
        }
*/

        function showWalkingRoute(map) {
          if (!window.userLocation || !window.userLocation.hasFix || !window.nearestStop) {
            setStatus('Need your location and nearest stop first.', 'status-warn');
            return;
          }

          const fromLat = window.userLocation.lat;
          const fromLng = window.userLocation.lng;
          const toLat = window.nearestStop.lat;
          const toLng = window.nearestStop.lon;

          const url = buildDirectionsUrl(fromLng, fromLat, toLng, toLat);

          fetch(url)
            .then(r => {
              if (!r.ok) throw new Error('HTTP ' + r.status);
              return r.json();
            })
            .then(json => {
              if (!json.routes?.length) {
                setStatus('No walking route found.', 'status-warn');
                return;
              }

              const route = json.routes[0];
              const feature = {
                type: 'Feature',
                properties: {},
                geometry: route.geometry
              };

              // Insert / update source
              if (map.getSource("walking-route")) {
                map.getSource("walking-route").setData(feature);
              } else {
                map.addSource("walking-route", {
                  type: "geojson",
                  data: feature
                });
              }

              if (!map.getLayer("walking-route-line")) {
                map.addLayer({
                  id: "walking-route-line",
                  type: "line",
                  source: "walking-route",
                  paint: {
                    "line-color": "#22c55e",
                    "line-width": 4,
                    "line-dasharray": [1.5, 1.5]
                  }
                });
              }

              // ALWAYS zoom AFTER map repaints
              map.once("idle", () => {
                try {
                  const bounds = new mapboxgl.LngLatBounds();
                  route.geometry.coordinates.forEach(c => bounds.extend(c));

                  map.fitBounds(bounds, {
                    padding: 60,
                    duration: 1200    // smooth guaranteed zoom
                  });
                } catch (err) {
                  console.warn("Walk zoom failed", err);
                }
              });

              const dist = Math.round(route.distance || 0);
              setStatus(`Walking route ready (~${dist} m)`, "status-info");
            })
            .catch(err => {
              console.error("directions error", err);
              setStatus("Failed to load walking route", "status-warn");
            });
        }

        var nearestBtn = document.getElementById('nearest-btn');
        if (nearestBtn) {
          nearestBtn.addEventListener('click', function () {
            findNearestRouteStop(map);
          });
        }

        var walkBtn = document.getElementById('walk-btn');
        if (walkBtn) {
          walkBtn.addEventListener('click', function () {
            showWalkingRoute(map);
          });
        }
                // --- Routes list: nearest 4 + search / paging ---
        var state = { currentRouteId: 'FF1', currentDir: 0 };

        function loadRoutesList() {
          var url = '/api/routes/nearby';
          if (window.userLocation && window.userLocation.hasFix) {
            url +=
              '?lat=' + encodeURIComponent(window.userLocation.lat) +
              '&lng=' + encodeURIComponent(window.userLocation.lng);
          }

          fetchJSON(url)
            .then(function (payload) {
              ALL_ROUTES = payload.routes || [];
              // Only show the 4 closest by default
              NEAREST_ROUTES = ALL_ROUTES.slice(0, 6);

              renderRoutePages(NEAREST_ROUTES);

              // Wire search once
              var searchInput = document.getElementById('routeSearch');
              if (searchInput && !searchInput.dataset.wired) {
                searchInput.dataset.wired = 'true';
                searchInput.addEventListener('input', function (e) {
                  var term = e.target.value.trim().toLowerCase();

                  if (!term) {
                    // empty search → back to 4 nearest
                    renderRoutePages(NEAREST_ROUTES);
                    return;
                  }

                  var filtered = ALL_ROUTES.filter(function (r) {
                    var shortName = (r.route_short_name || '').toLowerCase();
                    var longName = (r.route_long_name || '').toLowerCase();
                    return (
                      shortName.indexOf(term) !== -1 ||
                      longName.indexOf(term) !== -1
                    );
                  });

                  renderRoutePages(filtered);
                });
              }
            })
            .catch(function (err) {
              console.error('loadRoutesList error', err);
            });
        }

        // Draw a real GTFS route and then populate the sidebar
        loadRoute(map, state.currentRouteId, state.currentDir);
        loadRoutesList();
      });
      map.on('error', function (e) {
        console.error('Mapbox GL error:', e && e.error ? e.error : e);
        setStatus('Map error: ' + (e && e.error && e.error.message ? e.error.message : 'see console'), 'status-warn');
      });
    }

    function initMapLibre() {
      // Load MapLibre JS and CSS and render a demo style as a fallback
      return loadCSS('https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css')
        .then(function () { return loadScript('https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js'); })
        .then(function () {
          if (typeof maplibregl === 'undefined') throw new Error('maplibregl undefined');
          var map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json',
            center: [-105.2705, 40.0150],
            zoom: 12
          });
          map.addControl(new maplibregl.NavigationControl(), 'bottom-right');
          map.on('load', function () {
            setStatus('fallback loaded (MapLibre)', 'status-info');

            // Use same API-driven flow as Mapbox path
            function fetchJSON(url) { return fetch(url).then(function (r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); }); }
            function stopsToFC(stops) { return { type: 'FeatureCollection', features: stops.map(function (s) { return { type: 'Feature', properties: { name: s.stop_name }, geometry: { type: 'Point', coordinates: [+s.lon, +s.lat] } }; }) }; }
            function upsertSource(map, id, data) { if (map.getSource(id)) { map.getSource(id).setData(data); } else { map.addSource(id, { type: 'geojson', data: data }); } }
            function ensureLayers(map) {
              if (!map.getLayer('route-line')) {
                map.addLayer({ id: 'route-line', type: 'line', source: 'route', paint: { 'line-color': '#2563eb', 'line-width': 4 } });
              }
              if (!map.getLayer('stops-circles')) {
                map.addLayer({ id: 'stops-circles', type: 'circle', source: 'stops', paint: { 'circle-radius': 5, 'circle-color': '#ef4444', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 } });
              }
              if (!map.getLayer('stops-labels')) {
                map.addLayer({ id: 'stops-labels', type: 'symbol', source: 'stops', layout: { 'text-field': ['get', 'name'], 'text-size': 12, 'text-offset': [0, 1.2], 'text-anchor': 'top' }, paint: { 'text-color': '#111827' } });
              }
            }
            function fitToShape(map, shapeFC) { try { var Bounds = (window.mapboxgl && mapboxgl.LngLatBounds) || (window.maplibregl && maplibregl.LngLatBounds); var b = new Bounds(); var coords = shapeFC.features[0].geometry.coordinates; coords.forEach(function (c) { b.extend(c); }); map.fitBounds(b, { padding: 50, duration: 0 }); } catch (e) { console.warn('fit bounds failed', e); } }

            function loadRoute(map, routeId, directionId) {
              Promise.all([
                fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/shape?direction_id=' + directionId),
                fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/stops?direction_id=' + directionId)
              ]).then(function (results) {
                var shape = results[0];
                var stops = results[1];
                upsertSource(map, 'route', shape);
                upsertSource(map, 'stops', stopsToFC(stops));
                ensureLayers(map);
                fitToShape(map, shape);
                setStatus('Route ' + routeId + ' dir ' + directionId + ' loaded', 'status-info');
                startEstimatePolling(map, routeId, directionId);
              }).catch(function (err) { console.error('loadRoute error', err); setStatus('loadRoute error: ' + err.message, 'status-warn'); });
            }

            var estimateTimer = null;
            var estimateMarker = null;
            function updateEstimate(map, routeId, directionId) {
              fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/estimate?direction_id=' + directionId)
                .then(function (e) {
                  if (!e || !e.position) return;
                  var lngLat = [e.position.lng, e.position.lat];
                  if (!estimateMarker) {
                    var el = document.createElement('div');
                    el.style.width = '18px'; el.style.height = '18px';
                    el.style.background = '#10b981'; el.style.border = '2px solid #fff';
                    el.style.borderRadius = '50%'; el.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
                    el.title = 'Estimated Bus';
                    estimateMarker = new maplibregl.Marker({ element: el })
                      .setLngLat(lngLat)
                      .addTo(map);
                  } else {
                    estimateMarker.setLngLat(lngLat);
                  }
                })
                .catch(function (err) { console.error('estimate fetch error', err); });
            }
            function startEstimatePolling(map, routeId, directionId) {
              if (estimateTimer) { clearInterval(estimateTimer); estimateTimer = null; }
              if (estimateMarker && estimateMarker.remove) { estimateMarker.remove(); estimateMarker = null; }
              updateEstimate(map, routeId, directionId);
              estimateTimer = setInterval(function () { updateEstimate(map, routeId, directionId); }, 25000);
            }

            var state = { currentRouteId: 'FF1', currentDir: 0 };
            function selectRoute(routeId) {
              fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/directions')
                .then(function (dirs) {
                  var dir = Array.isArray(dirs) && dirs.length ? dirs[0] : 0;
                  state.currentRouteId = routeId; state.currentDir = dir;
                  loadRoute(map, routeId, dir);
                })
                .catch(function (err) { console.error('directions error', err); setStatus('directions error: ' + err.message, 'status-warn'); });
            }
            function loadRoutesList() {
              fetchJSON('/api/routes')
                .then(function (routes) {
                  var ul = document.getElementById('routeList');
                  var countEl = document.getElementById('routesCount');
                  if (countEl) countEl.textContent = '(' + routes.length + ')';
                  ul.innerHTML = '';
                  routes.slice(0, 40).forEach(function (r) {
                    var li = document.createElement('li');
                    var btn = document.createElement('button');
                    btn.type = 'button';
                    btn.textContent = (r.route_short_name || r.route_id) + ' — ' + (r.route_long_name || '');
                    btn.style.cssText = 'display:block;width:100%;text-align:left;padding:4px 6px;margin:2px 0;border:1px solid #ddd;border-radius:4px;background:#f8f9fa;cursor:pointer;';
                    btn.addEventListener('click', function () { selectRoute(r.route_id); });
                    li.appendChild(btn);
                    ul.appendChild(li);
                  });
                })
                .catch(function (err) { console.error('loadRoutesList error', err); });
            }

            // Start with default and load list
            loadRoute(map, state.currentRouteId, state.currentDir);
            loadRoutesList();
          });
          map.on('error', function (e) { console.error('MapLibre error:', e); setStatus('MapLibre error: see console', 'status-warn'); });
        })
        .catch(function (e) { console.error(e); setStatus('Fallback failed to load. See console.', 'status-warn'); });
    }

    function start() {
      if (!tokenFromServer || tokenFromServer === '' || tokenFromServer === 'undefined') {
        console.error('Mapbox access token is missing. Set MAPBOX_ACCESS_TOKEN in your .env and restart.');
        return;
      }
      initMapbox();
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      start();
    } else {
      window.addEventListener('DOMContentLoaded', start);
    }
  })();
</script>