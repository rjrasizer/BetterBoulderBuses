<!-- Full-page Mapbox map for Better Boulder Buses -->
<style>
  /* Hide the global footer on the map page to avoid overlaying the map */
  footer {
    display: none;
  }

  html,
  body {
    height: 100%;
    margin: 0;
  }

  /* Ensure the map fills the visible page area */
  #map {
    position: fixed;
    /* Fully cover the viewport regardless of page flow */
    inset: 0;
    width: 100%;
    height: 100%;
    background: #f5f5f5;
    /* fallback background before tiles load */
  }

  /* Optional: a small overlay to verify the page loaded */
  .overlay {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 1;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 14px;
    color: #333;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);
  }

  .overlay .status-ok {
    color: #198754;
  }

  .overlay .status-warn {
    color: #dc3545;
  }

  .overlay .status-info {
    color: #0d6efd;
  }


  #settings-btn {
    position: fixed;
    top: 16px;
    right: 16px;
    z-index: 10;
  }


  #settings-btn a {
    display: flex;
    align-items: center;
    justify-content: center;


    width: 42px;
    height: 42px;


    background: rgba(255, 255, 255, 0.9);
    border-radius: 12px;


    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(6px);


    text-decoration: none;
    color: #333;
    transition: background 0.2s ease, transform 0.2s ease;
  }


  #settings-btn i {
    font-size: 20px;
  }


  /* Continuous spin animation */
  @keyframes spin-gear {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }


  #settings-btn:hover a {
    background: rgba(255, 255, 255, 1);
  }


  #settings-btn:hover i {
    animation: spin-gear 0.8s linear infinite;
  }


  #recenter-btn {
    position: fixed;
    top: 68px;
    right: 16px;
    z-index: 10;
    padding: 8px 12px;
    border-radius: 999px;
    border: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    font-size: 14px;
  }

  #recenter-btn:hover {
    background: #ffffff;
  }

  #nearest-btn {
    position: fixed;
    top: 112px;
    right: 16px;
    z-index: 10;
    padding: 8px 12px;
    border-radius: 999px;
    border: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    font-size: 14px;
  }

  #nearest-btn:hover {
    background: #ffffff;
  }

  #walk-btn {
    position: fixed;
    top: 156px;
    right: 16px;
    z-index: 10;
    padding: 8px 12px;
    border-radius: 999px;
    border: none;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    font-size: 14px;
  }

  #walk-btn:hover {
    background: #ffffff;
  }


</style>

<link rel="stylesheet" href="/css/sidebar.css" />
<!-- Mapbox GL JS CSS is included in main layout head -->

<div class="overlay">
  <strong>Better Boulder Buses</strong>
  <span> — Map status:
    {{#if mapboxToken}}<span id="map-status" class="status-ok">token set</span>{{else}}<span id="map-status"
      class="status-warn">missing token</span>{{/if}}
  </span>
  {{#if title}}<div>{{title}}</div>{{/if}}
  <div style="font-size: 12px; color: #666;">/home</div>
  <div id="diag" style="font-size:12px;color:#666;max-width:320px;word-break:break-all"></div>
  <!-- MVP: Simple routes list -->
  <div id="routesPanel"
    style="margin-top:8px;max-height:220px;overflow:auto;border:1px solid #ddd;border-radius:6px;padding:6px;background:#fff;min-width:260px;">
    <div style="font-weight:600;margin-bottom:6px;display:flex;align-items:center;gap:8px;">
      <span>Routes</span>
      <span id="routesCount" style="font-size:12px;color:#666;"></span>
    </div>
    <ul id="routeList" style="list-style:none;padding:0;margin:0;font-size:13px;line-height:1.4;"></ul>
  </div>
</div>

<div id="settings-btn">
  <a href="/settings" aria-label="Open settings">
    <i class="bi bi-gear-fill"></i>
  </a>
</div>

<button
  id="recenter-btn"
  type="button"
  aria-label="Center on my location"
>
  Center on me
</button>

<button
  id="nearest-btn"
  type="button"
  aria-label="Find nearest route and stop"
>
  Nearest stop
</button>

<button
  id="walk-btn"
  type="button"
  aria-label="Show walking route to nearest stop"
>
  Walk to stop
</button>

<div id="map" role="region" aria-label="Interactive transit map"></div>

<a href="/settings" class="position-fixed top-0 end-0 m-3 text-dark">
  <i class="bi bi-gear-fill fs-3"></i>
</a>

<div class="sidebar is-closed">
  <button class="sidebar-toggle is-closed">
    <i class="fa fa-plus icon"></i>
  </button>

  <div class="sidebar-header">
    <h2 class="sidebar-title">Routes</h2>
  </div>
  <div class="sidebar-scroll-container">
    <ul class="sidebar-route-list" id="sidebarRouteList">
      {{!-- will have sidebar data entries here --}}
    </ul>
  </div>
</div>

{{!-- <!-- Sidebar (mobile + desktop) -->
<div class="sidebar is-closed">
  <div class="sidebar-header">
    <h2 class="sidebar-title">Routes</h2>
  </div>
  <ul class="sidebar-route-list" id="sidebarRouteList">
    <!-- sidebar content -->
  </ul>
</div>

<!-- Toggle button (always visible, independent) -->
<button class="sidebar-toggle is-closed">
  <i class="fa fa-plus icon"></i>
</button> --}}

<!-- Mapbox GL JS script -->
<script src="https://api.mapbox.com/mapbox-gl-js/v2.16.1/mapbox-gl.js"></script>

<!-- Sidebar Script -->
<script src="js/script.js"></script>

<script>
  (function () {
    // Token passed from server via template
    var tokenFromServer = '{{mapboxToken}}';

    if (!tokenFromServer || tokenFromServer === '' || tokenFromServer === 'undefined') {
      console.error('Mapbox access token is missing. Set MAPBOX_ACCESS_TOKEN in your .env and restart.');
      return;
    }

    function setStatus(text, cls) {
      var s = document.getElementById('map-status');
      if (s) { s.className = cls || 'status-info'; s.textContent = text; }
      var d = document.getElementById('diag');
      if (d) d.textContent = text;
    }

    function loadScript(src) {
      return new Promise(function (resolve, reject) {
        var s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = resolve;
        s.onerror = function (e) { reject(new Error('Failed to load ' + src)); };
        document.head.appendChild(s);
      });
    }

    function loadCSS(href) {
      return new Promise(function (resolve, reject) {
        var l = document.createElement('link');
        l.rel = 'stylesheet';
        l.href = href;
        l.onload = resolve;
        l.onerror = function () { reject(new Error('Failed to load ' + href)); };
        document.head.appendChild(l);
      });
    }

    function initMapbox() {
      if (typeof mapboxgl === 'undefined') {
        console.warn('mapboxgl undefined before init; attempting alternate CDN...');
        // Try alternate CDN (unpkg) with a known version
        return Promise.all([
          loadCSS('https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.css'),
          loadScript('https://unpkg.com/mapbox-gl@2.15.0/dist/mapbox-gl.js')
        ])
          .then(function () {
            if (typeof mapboxgl === 'undefined') throw new Error('mapboxgl still undefined after alternate CDN');
            return createMapboxMap();
          })
          .catch(function (err) {
            console.error(err);
            setStatus('Mapbox GL JS failed (blockers?). Falling back to MapLibre…', 'status-warn');
            return initMapLibre();
          });
      }
      return createMapboxMap();
    }

    function createMapboxMap() {
      mapboxgl.accessToken = tokenFromServer;
      if (!mapboxgl.supported()) {
        console.error('WebGL not supported in this browser/device.');
        setStatus('WebGL not supported. Enable hardware acceleration or try another browser.', 'status-warn');
        return;
      }
      var map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [-105.2705, 40.0150],
        zoom: 12
      });

      // -----------------------------
      // USER LOCATION
      // -----------------------------

      // Make sure browser supports location
      if ("geolocation" in navigator) {
        navigator.geolocation.watchPosition(
          (position) => {
            const userLng = position.coords.longitude;
            const userLat = position.coords.latitude;

            // Track latest user location for nearest-stop logic
            window.userLocation = {
              lat: userLat,
              lng: userLng,
              hasFix: true
            };

            // If marker doesn't exist yet, create it
            if (!window.userMarker) {
              window.userMarker = new mapboxgl.Marker({
                color: "rgb(207, 184, 124)"  // optional: your chosen color
              })
                .setLngLat([userLng, userLat])
                .addTo(map);

              // Optionally center map on the user the first time
              map.flyTo({ center: [userLng, userLat], zoom: 14 });
            } else {
              // Update existing marker
              window.userMarker.setLngLat([userLng, userLat]);
            }
          },

          (error) => {
            console.error("Geolocation error:", error.message);
            window.userLocation = { hasFix: false };
          },

          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 10000
          }
        );
      } else {
        console.error("Geolocation not supported by this browser.");
      }

      // Recenter-on-user button
      var recenterBtn = document.getElementById('recenter-btn');
      if (recenterBtn) {
        recenterBtn.addEventListener('click', function () {
          // If we already have a user marker, use its position
          if (window.userMarker && typeof window.userMarker.getLngLat === 'function') {
            var lngLat = window.userMarker.getLngLat();
            map.flyTo({ center: [lngLat.lng, lngLat.lat], zoom: 14 });
            return;
          }

          // Fallback: ask for current position once
          if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition(
              function (position) {
                var userLng = position.coords.longitude;
                var userLat = position.coords.latitude;

                // Update cached user location
                window.userLocation = {
                  lat: userLat,
                  lng: userLng,
                  hasFix: true
                };

                if (!window.userMarker) {
                  window.userMarker = new mapboxgl.Marker({
                    color: "rgb(207, 184, 124)"
                  })
                    .setLngLat([userLng, userLat])
                    .addTo(map);
                } else {
                  window.userMarker.setLngLat([userLng, userLat]);
                }

                map.flyTo({ center: [userLng, userLat], zoom: 14 });
              },
              function (error) {
                console.error("Geolocation error (recenter):", error.message);
              },
              {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000
              }
            );
          }
        });
      }

      map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
      map.on('load', function () {
        setStatus('loaded', 'status-info');

        // Helpers shared by Mapbox GL + MapLibre
        function fetchJSON(url) { return fetch(url).then(function (r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); }); }
        function stopsToFC(stops) { return { type: 'FeatureCollection', features: stops.map(function (s) { return { type: 'Feature', properties: { name: s.stop_name }, geometry: { type: 'Point', coordinates: [+s.lon, +s.lat] } }; }) }; }
        function upsertSource(map, id, data) { if (map.getSource(id)) { map.getSource(id).setData(data); } else { map.addSource(id, { type: 'geojson', data: data }); } }
        function ensureLayers(map) {
          if (!map.getLayer('route-line')) {
            map.addLayer({ id: 'route-line', type: 'line', source: 'route', paint: { 'line-color': '#2563eb', 'line-width': 4 } });
          }
          if (!map.getLayer('stops-circles')) {
            map.addLayer({ id: 'stops-circles', type: 'circle', source: 'stops', paint: { 'circle-radius': 5, 'circle-color': '#ef4444', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 } });
          }
          if (!map.getLayer('stops-labels')) {
            map.addLayer({ id: 'stops-labels', type: 'symbol', source: 'stops', layout: { 'text-field': ['get', 'name'], 'text-size': 12, 'text-offset': [0, 1.2], 'text-anchor': 'top' }, paint: { 'text-color': '#111827' } });
          }
        }
        function fitToShape(map, shapeFC) { try { var Bounds = (window.mapboxgl && mapboxgl.LngLatBounds) || (window.maplibregl && maplibregl.LngLatBounds); var b = new Bounds(); var coords = shapeFC.features[0].geometry.coordinates; coords.forEach(function (c) { b.extend(c); }); map.fitBounds(b, { padding: 50, duration: 0 }); } catch (e) { console.warn('fit bounds failed', e); } }

        function loadRoute(map, routeId, directionId) {
          Promise.all([
            fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/shape?direction_id=' + directionId),
            fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/stops?direction_id=' + directionId)
          ]).then(function (results) {
            var shape = results[0];
            var stops = results[1];
            upsertSource(map, 'route', shape);
            upsertSource(map, 'stops', stopsToFC(stops));
            ensureLayers(map);
            fitToShape(map, shape);
            setStatus('Route ' + routeId + ' dir ' + directionId + ' loaded', 'status-info');

            // Kick off estimate polling for this route/direction
            startEstimatePolling(map, routeId, directionId);
          }).catch(function (err) { console.error('loadRoute error', err); setStatus('loadRoute error: ' + err.message, 'status-warn'); });
        }

        // --- Estimated position polling (every ~25s) ---
        var estimateTimer = null;
        var estimateMarker = null;
        function updateEstimate(map, routeId, directionId) {
          fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/estimate?direction_id=' + directionId)
            .then(function (e) {
              if (!e || !e.position) return;
              var lngLat = [e.position.lng, e.position.lat];
              if (!estimateMarker) {
                var el = document.createElement('div');
                el.style.width = '18px';
                el.style.height = '18px';
                el.style.background = '#10b981';
                el.style.border = '2px solid #fff';
                el.style.borderRadius = '50%';
                el.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
                el.title = 'Estimated Bus';
                estimateMarker = new mapboxgl.Marker({ element: el, rotationAlignment: 'map' })
                  .setLngLat(lngLat)
                  .addTo(map);
              } else {
                estimateMarker.setLngLat(lngLat);
              }
            })
            .catch(function (err) { console.error('estimate fetch error', err); });
        }
        function startEstimatePolling(map, routeId, directionId) {
          if (estimateTimer) { clearInterval(estimateTimer); estimateTimer = null; }
          // reset existing marker between routes
          if (estimateMarker && estimateMarker.remove) { estimateMarker.remove(); estimateMarker = null; }
          // initial fetch immediately
          updateEstimate(map, routeId, directionId);
          // poll roughly every 25 seconds
          estimateTimer = setInterval(function () { updateEstimate(map, routeId, directionId); }, 25000);
        }

        // --- Nearest route + stop to user ---
        function highlightNearestStopOnMap(map, stop) {
          var sourceId = 'nearest-stop';
          var layerId = 'nearest-stop-circle';
          var fc = {
            type: 'FeatureCollection',
            features: [{
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'Point',
                coordinates: [stop.lon, stop.lat]
              }
            }]
          };

          if (map.getSource(sourceId)) {
            map.getSource(sourceId).setData(fc);
          } else {
            map.addSource(sourceId, {
              type: 'geojson',
              data: fc
            });
          }

          if (!map.getLayer(layerId)) {
            map.addLayer({
              id: layerId,
              type: 'circle',
              source: sourceId,
              paint: {
                'circle-radius': 8,
                'circle-color': '#22c55e',
                'circle-stroke-color': '#ffffff',
                'circle-stroke-width': 2
              }
            });
          }
        }

        function findNearestRouteStop(map) {
          if (!window.userLocation || !window.userLocation.hasFix) {
            setStatus('Waiting for your location…', 'status-warn');
            return;
          }

          var lat = window.userLocation.lat;
          var lng = window.userLocation.lng;

          fetchJSON('/api/nearest?lat=' + encodeURIComponent(lat) + '&lng=' + encodeURIComponent(lng))
            .then(function (data) {
              window.nearestStop = data.stop;
              window.nearestRoute = {
                routeId: data.route_id,
                directionId: data.direction_id
              };

              var label = (data.route_short_name || data.route_id) + ' — ' + (data.stop.stop_name || '');
              var dist = typeof data.distance_meters === 'number'
                ? Math.round(data.distance_meters)
                : null;
              var statusText = 'Nearest: ' + label;
              if (dist !== null) statusText += ' (~' + dist + ' m)';
              setStatus(statusText, 'status-info');

              loadRoute(map, data.route_id, data.direction_id);
              highlightNearestStopOnMap(map, data.stop);
            })
            .catch(function (err) {
              console.error('nearest error', err);
              setStatus('Failed to find nearest stop', 'status-warn');
            });
        }

        function buildDirectionsUrl(fromLng, fromLat, toLng, toLat) {
          var token = tokenFromServer;
          var coords = fromLng + ',' + fromLat + ';' + toLng + ',' + toLat;
          return 'https://api.mapbox.com/directions/v5/mapbox/walking/'
            + coords
            + '?geometries=geojson&overview=full&access_token=' + encodeURIComponent(token);
        }

        function showWalkingRoute(map) {
          if (!window.userLocation || !window.userLocation.hasFix || !window.nearestStop) {
            setStatus('Need your location and nearest stop first.', 'status-warn');
            return;
          }

          var fromLat = window.userLocation.lat;
          var fromLng = window.userLocation.lng;
          var toLat = window.nearestStop.lat;
          var toLng = window.nearestStop.lon;

          var url = buildDirectionsUrl(fromLng, fromLat, toLng, toLat);

          fetch(url)
            .then(function (r) {
              if (!r.ok) throw new Error('HTTP ' + r.status);
              return r.json();
            })
            .then(function (json) {
              if (!json.routes || !json.routes.length || !json.routes[0].geometry) {
                setStatus('No walking route found.', 'status-warn');
                return;
              }

              var route = json.routes[0];
              var geometry = route.geometry;
              var sourceId = 'walking-route';
              var layerId = 'walking-route-line';
              var feature = {
                type: 'Feature',
                properties: {},
                geometry: geometry
              };

              if (map.getSource(sourceId)) {
                map.getSource(sourceId).setData(feature);
              } else {
                map.addSource(sourceId, {
                  type: 'geojson',
                  data: feature
                });
              }

              if (!map.getLayer(layerId)) {
                map.addLayer({
                  id: layerId,
                  type: 'line',
                  source: sourceId,
                  paint: {
                    'line-color': '#22c55e',
                    'line-width': 4,
                    'line-dasharray': [1.5, 1.5]
                  }
                });
              }

              try {
                var bounds = new mapboxgl.LngLatBounds();
                geometry.coordinates.forEach(function (c) { bounds.extend(c); });
                map.fitBounds(bounds, { padding: 60 });
              } catch (e) {
                console.warn('walk fit failed', e);
              }

              var dist = typeof route.distance === 'number' ? Math.round(route.distance) : null;
              var statusText = 'Walking route ready';
              if (dist !== null) statusText += ' (~' + dist + ' m)';
              setStatus(statusText, 'status-info');
            })
            .catch(function (err) {
              console.error('directions error', err);
              setStatus('Failed to load walking route', 'status-warn');
            });
        }

        var nearestBtn = document.getElementById('nearest-btn');
        if (nearestBtn) {
          nearestBtn.addEventListener('click', function () {
            findNearestRouteStop(map);
          });
        }

        var walkBtn = document.getElementById('walk-btn');
        if (walkBtn) {
          walkBtn.addEventListener('click', function () {
            showWalkingRoute(map);
          });
        }

        // --- Routes list (MVP) ---
        var state = { currentRouteId: 'FF1', currentDir: 0 };
        function selectRoute(routeId) {
          // Get available directions; pick the first
          fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/directions')
            .then(function (dirs) {
              var dir = Array.isArray(dirs) && dirs.length ? dirs[0] : 0;
              state.currentRouteId = routeId; state.currentDir = dir;
              loadRoute(map, routeId, dir);
            })
            .catch(function (err) { console.error('directions error', err); setStatus('directions error: ' + err.message, 'status-warn'); });
        }
        function loadRoutesList() {
          fetchJSON('/api/routes')
            .then(function (routes) {
              var ul = document.getElementById('routeList');
              var countEl = document.getElementById('routesCount');
              if (countEl) countEl.textContent = '(' + routes.length + ')';
              ul.innerHTML = '';
              routes.slice(0, 40).forEach(function (r) {
                var li = document.createElement('li');
                var btn = document.createElement('button');
                btn.type = 'button';
                btn.textContent = (r.route_short_name || r.route_id) + ' — ' + (r.route_long_name || '');
                btn.style.cssText = 'display:block;width:100%;text-align:left;padding:4px 6px;margin:2px 0;border:1px solid #ddd;border-radius:4px;background:#f8f9fa;cursor:pointer;';
                btn.addEventListener('click', function () { selectRoute(r.route_id); });
                li.appendChild(btn);
                ul.appendChild(li);
              });
            })
            .catch(function (err) { console.error('loadRoutesList error', err); });
        }

        // Draw a real GTFS route without adding any extra HTML
        loadRoute(map, state.currentRouteId, state.currentDir);
        loadRoutesList();
      });
      map.on('error', function (e) {
        console.error('Mapbox GL error:', e && e.error ? e.error : e);
        setStatus('Map error: ' + (e && e.error && e.error.message ? e.error.message : 'see console'), 'status-warn');
      });
    }

    function initMapLibre() {
      // Load MapLibre JS and CSS and render a demo style as a fallback
      return loadCSS('https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css')
        .then(function () { return loadScript('https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js'); })
        .then(function () {
          if (typeof maplibregl === 'undefined') throw new Error('maplibregl undefined');
          var map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json',
            center: [-105.2705, 40.0150],
            zoom: 12
          });
          map.addControl(new maplibregl.NavigationControl(), 'bottom-right');
          map.on('load', function () {
            setStatus('fallback loaded (MapLibre)', 'status-info');

            // Use same API-driven flow as Mapbox path
            function fetchJSON(url) { return fetch(url).then(function (r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); }); }
            function stopsToFC(stops) { return { type: 'FeatureCollection', features: stops.map(function (s) { return { type: 'Feature', properties: { name: s.stop_name }, geometry: { type: 'Point', coordinates: [+s.lon, +s.lat] } }; }) }; }
            function upsertSource(map, id, data) { if (map.getSource(id)) { map.getSource(id).setData(data); } else { map.addSource(id, { type: 'geojson', data: data }); } }
            function ensureLayers(map) {
              if (!map.getLayer('route-line')) {
                map.addLayer({ id: 'route-line', type: 'line', source: 'route', paint: { 'line-color': '#2563eb', 'line-width': 4 } });
              }
              if (!map.getLayer('stops-circles')) {
                map.addLayer({ id: 'stops-circles', type: 'circle', source: 'stops', paint: { 'circle-radius': 5, 'circle-color': '#ef4444', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1 } });
              }
              if (!map.getLayer('stops-labels')) {
                map.addLayer({ id: 'stops-labels', type: 'symbol', source: 'stops', layout: { 'text-field': ['get', 'name'], 'text-size': 12, 'text-offset': [0, 1.2], 'text-anchor': 'top' }, paint: { 'text-color': '#111827' } });
              }
            }
            function fitToShape(map, shapeFC) { try { var Bounds = (window.mapboxgl && mapboxgl.LngLatBounds) || (window.maplibregl && maplibregl.LngLatBounds); var b = new Bounds(); var coords = shapeFC.features[0].geometry.coordinates; coords.forEach(function (c) { b.extend(c); }); map.fitBounds(b, { padding: 50, duration: 0 }); } catch (e) { console.warn('fit bounds failed', e); } }

            function loadRoute(map, routeId, directionId) {
              Promise.all([
                fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/shape?direction_id=' + directionId),
                fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/stops?direction_id=' + directionId)
              ]).then(function (results) {
                var shape = results[0];
                var stops = results[1];
                upsertSource(map, 'route', shape);
                upsertSource(map, 'stops', stopsToFC(stops));
                ensureLayers(map);
                fitToShape(map, shape);
                setStatus('Route ' + routeId + ' dir ' + directionId + ' loaded', 'status-info');
                startEstimatePolling(map, routeId, directionId);
              }).catch(function (err) { console.error('loadRoute error', err); setStatus('loadRoute error: ' + err.message, 'status-warn'); });
            }

            var estimateTimer = null;
            var estimateMarker = null;
            function updateEstimate(map, routeId, directionId) {
              fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/estimate?direction_id=' + directionId)
                .then(function (e) {
                  if (!e || !e.position) return;
                  var lngLat = [e.position.lng, e.position.lat];
                  if (!estimateMarker) {
                    var el = document.createElement('div');
                    el.style.width = '18px'; el.style.height = '18px';
                    el.style.background = '#10b981'; el.style.border = '2px solid #fff';
                    el.style.borderRadius = '50%'; el.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
                    el.title = 'Estimated Bus';
                    estimateMarker = new maplibregl.Marker({ element: el })
                      .setLngLat(lngLat)
                      .addTo(map);
                  } else {
                    estimateMarker.setLngLat(lngLat);
                  }
                })
                .catch(function (err) { console.error('estimate fetch error', err); });
            }
            function startEstimatePolling(map, routeId, directionId) {
              if (estimateTimer) { clearInterval(estimateTimer); estimateTimer = null; }
              if (estimateMarker && estimateMarker.remove) { estimateMarker.remove(); estimateMarker = null; }
              updateEstimate(map, routeId, directionId);
              estimateTimer = setInterval(function () { updateEstimate(map, routeId, directionId); }, 25000);
            }

            var state = { currentRouteId: 'FF1', currentDir: 0 };
            function selectRoute(routeId) {
              fetchJSON('/api/routes/' + encodeURIComponent(routeId) + '/directions')
                .then(function (dirs) {
                  var dir = Array.isArray(dirs) && dirs.length ? dirs[0] : 0;
                  state.currentRouteId = routeId; state.currentDir = dir;
                  loadRoute(map, routeId, dir);
                })
                .catch(function (err) { console.error('directions error', err); setStatus('directions error: ' + err.message, 'status-warn'); });
            }
            function loadRoutesList() {
              fetchJSON('/api/routes')
                .then(function (routes) {
                  var ul = document.getElementById('routeList');
                  var countEl = document.getElementById('routesCount');
                  if (countEl) countEl.textContent = '(' + routes.length + ')';
                  ul.innerHTML = '';
                  routes.slice(0, 40).forEach(function (r) {
                    var li = document.createElement('li');
                    var btn = document.createElement('button');
                    btn.type = 'button';
                    btn.textContent = (r.route_short_name || r.route_id) + ' — ' + (r.route_long_name || '');
                    btn.style.cssText = 'display:block;width:100%;text-align:left;padding:4px 6px;margin:2px 0;border:1px solid #ddd;border-radius:4px;background:#f8f9fa;cursor:pointer;';
                    btn.addEventListener('click', function () { selectRoute(r.route_id); });
                    li.appendChild(btn);
                    ul.appendChild(li);
                  });
                })
                .catch(function (err) { console.error('loadRoutesList error', err); });
            }

            // Start with default and load list
            loadRoute(map, state.currentRouteId, state.currentDir);
            loadRoutesList();
          });
          map.on('error', function (e) { console.error('MapLibre error:', e); setStatus('MapLibre error: see console', 'status-warn'); });
        })
        .catch(function (e) { console.error(e); setStatus('Fallback failed to load. See console.', 'status-warn'); });
    }

    function start() {
      if (!tokenFromServer || tokenFromServer === '' || tokenFromServer === 'undefined') {
        console.error('Mapbox access token is missing. Set MAPBOX_ACCESS_TOKEN in your .env and restart.');
        return;
      }
      initMapbox();
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      start();
    } else {
      window.addEventListener('DOMContentLoaded', start);
    }
  })();
</script>
